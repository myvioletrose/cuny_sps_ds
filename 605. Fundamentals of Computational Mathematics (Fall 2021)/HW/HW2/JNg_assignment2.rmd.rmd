---
title: "data_605_hw2"
author: "Jimmy Ng"
date: "9/3/2021"
output:
  rmdformats::readthedown:
    self_contained: yes
    thumbnails: yes
    lightbox: yes
    gallery: no
    highlight: tango
    code_folding: hide
editor_options: 
  chunk_output_type: console
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  echo = TRUE, 
  warning = FALSE, 
  message = FALSE,
  cache = FALSE)

packages <- c(
  'tidyverse' 
)
for (pkg in packages) {
  suppressPackageStartupMessages(suppressWarnings(
    library(
      pkg, character.only = TRUE, 
      warn.conflicts = FALSE, quietly = TRUE)
  ))
}

# A ggplot2 function
defaulttheme <- theme(
  panel.background = element_blank(),
  panel.border = element_rect(color = "black", fill = NA))
```

## HW2

## (1) Problem Set 1.1 {.tabset .tabset-fade .tabset-pills} 

### step 1

Prove the following

$$
{ A }^{ T }A \neq A{ A }^{ T }
$$
Suppose we have matrix A and its transpose

$$
A=\begin{bmatrix} a & b \\ c & d \end{bmatrix}
\\{ A }^{ T }=\begin{bmatrix} a & c \\ b & d \end{bmatrix}
$$

### step 2

Using matrix multiplication to try get the following

$$
{ A }^{ T }A= A{ A }^{ T }\\
\begin{bmatrix} a & c \\ b & d \end{bmatrix}
\begin{bmatrix} a & b \\ c & d \end{bmatrix}=
\begin{bmatrix} a & b \\ c & d \end{bmatrix}
\begin{bmatrix} a & c \\ b & d \end{bmatrix}\\
\begin{bmatrix} { a }^{ 2 }+{ c }^{ 2 } & ab+cd \\ ab+cd & { b }^{ 2 }+{ d }^{ 2 } \end{bmatrix}=
\begin{bmatrix} { a }^{ 2 }+{ b }^{ 2 } & ac+bd \\ ac+bd & { c }^{ 2 }+{ d }^{ 2 } \end{bmatrix}
$$

### step 3

Values from the left side is not equivalent to the right, so we have arrived at the conclusion that both sides are not equal

$$
\begin{bmatrix} { a }^{ 2 }+{ b }^{ 2 } & ab+cd \\ ab+cd & { b }^{ 2 }+{ d }^{ 2 } \end{bmatrix}\neq 
\begin{bmatrix} { a }^{ 2 }+{ b }^{ 2 } & ac+bd \\ ac+bd & { c }^{ 2 }+{ d }^{ 2 } \end{bmatrix}
$$

$$
{ A }^{ T }A\neq A{ A }^{ T }
$$

## (2) Problem Set 1.2 {.tabset .tabset-fade .tabset-pills} 

### step 1

For a special kind of matrix, let's try to show that

$$
{ A }^{ T }A = A{ A }^{ T }
$$

Suppose we have matrix A and its transpose

$$
A=\begin{bmatrix} a & b \\ b & a \end{bmatrix}
\\\ { A }^{ T }=\begin{bmatrix} a & b \\ b & a \end{bmatrix}
$$

### step 2

Using matrix multiplication to get the following

$$
{ A }^{ T }A= A{ A }^{ T }\\
\begin{bmatrix} a & b \\ b & a \end{bmatrix}
\begin{bmatrix} a & b \\ b & a \end{bmatrix}=
\begin{bmatrix} a & b \\ b & a \end{bmatrix}
\begin{bmatrix} a & b \\ b & a \end{bmatrix}\\
\begin{bmatrix} { a }^{ 2 }+{ b }^{ 2 } & ab+ba \\ ba+ab & { b }^{ 2 }+{ a }^{ 2 } \end{bmatrix}=
\begin{bmatrix} { a }^{ 2 }+{ b }^{ 2 } & ab+ba \\ ba+ab & { b }^{ 2 }+{ a }^{ 2 } \end{bmatrix}
$$

### step 3

Values from the left side is equivalent to the right, so we have arrived at the conclusion that both sides are the same

$$
\begin{bmatrix} { a }^{ 2 }+{ b }^{ 2 } & ab+ba \\ ba+ab & { b }^{ 2 }+{ a }^{ 2 } \end{bmatrix}=
\begin{bmatrix} { a }^{ 2 }+{ b }^{ 2 } & ab+ba \\ ba+ab & { b }^{ 2 }+{ a }^{ 2 } \end{bmatrix}
$$
$$
{ A }^{ T }A = A{ A }^{ T }
$$

## (3) Problem Set 2: Matrix Factorization

```{r, echo = TRUE}
LU_decompose <- function(m, print = TRUE){
    
    # this function works for square matrix only
    # inspired by this video: https://www.youtube.com/watch?v=UlWcofkUDDU
    
    # Upper Triangular Matrix
    utm = m
    
    d = dim(utm)[1]
    
    df = expand.grid(row_index = c(2:d), column_index = c(1:(d-1))) %>%
        as.data.frame %>%
        dplyr::filter(row_index > column_index) %>%
        arrange(row_index, column_index) %>% 
        dplyr::mutate(row_index_lookup = column_index)
    
    elimination_factor <- function(x, y){
        return(-y / x)
    }
    
    tempList <- vector(mode = "list", length = nrow(df))
    
    for(n in 1:nrow(df)){
        
        i = df$row_index[n]
        j = df$column_index[n]
        iLookup = df$row_index_lookup[n]
        
        ef = elimination_factor(utm[iLookup, j], utm[i, j])
        
        utm[i, ] = utm[iLookup, ] * ef + utm[i, ]
        
        tempList[[n]] = ef
        
    }
    
    df = df %>%
        dplyr::mutate(elimination_factor = tempList %>% unlist,
                      values_in_ltm = -1 * elimination_factor)
    
    # Lower Triangular Matrix
    ltm = diag(d)
    
    for(a in 1:nrow(df)){
        
        i = df$row_index[a]
        j = df$column_index[a]
        
        ltm[i, j] = df$values_in_ltm[a]
        
    }
    
    if(print){
        
        # return original Matrix
        print("Original Matrix")
        print(ltm %*% utm)
        
        # return Lower Triangular Matrix
        print("Lower Triangular Matrix")
        print(ltm)
        
        # return Upper Triangular Matrix
        print("Upper Triangular Matrix")
        print(utm)
        
    }
    
    return(list("ltm" = ltm, "utm" = utm))
    
}

m <- matrix(c(1, 2, 3, 
              1, 1, 1, 
              2, 0, 1), 
            nrow = 3)

m_decompose = LU_decompose(m, print = TRUE)
```
